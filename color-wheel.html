<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Color Wheel</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h2 {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 1rem;
        }
        .wheel-container {
            margin-bottom: 1.5rem;
            position: relative;
        }
        .color-wheel {
            cursor: grab;
            touch-action: none;
        }
        .color-tile {
            flex: 1;
            min-width: 8rem;
        }
        .color-tile-title {
            font-size: 0.875rem;
            font-weight: 500;
            margin-bottom: 0.25rem;
        }
        .color-tile-box {
            height: 4rem;
            width: 100%;
            border-radius: 0.25rem;
            border: 1px solid #e5e5e5;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        .color-tile-hsl {
            margin-top: 0.25rem;
            font-size: 0.75rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .color-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            width: 100%;
            max-width: 64rem;
        }
        .color-mix {
            border: 1px solid #e5e5e5;
            padding: 0.5rem;
            border-radius: 0.25rem;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        .help-text {
            margin-top: 1.5rem;
            font-size: 0.875rem;
            color: #666;
        }
        .reverse-picker {
            margin-top: 2rem;
            padding: 1rem;
            border: 1px solid #e5e5e5;
            border-radius: 0.25rem;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            width: 100%;
            max-width: 64rem;
        }
        .color-input-container {
            display: flex;
            gap: 1rem;
            align-items: center;
            margin-bottom: 1rem;
        }
        .color-input-container input[type="color"] {
            width: 100px;
            height: 40px;
            padding: 0;
            border: none;
            border-radius: 0.25rem;
            cursor: pointer;
        }
        .color-input-container button {
            padding: 0.5rem 1rem;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 0.25rem;
            cursor: pointer;
            font-size: 0.875rem;
        }
        .color-input-container button:hover {
            background-color: #0056b3;
        }
        .mixing-instructions {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
        }
        .mixing-card {
            border: 1px solid #e5e5e5;
            padding: 1rem;
            border-radius: 0.25rem;
            background-color: white;
        }
        .mixing-card h4 {
            margin: 0 0 0.5rem 0;
            font-size: 1rem;
        }
        .mixing-card .color-preview {
            height: 2rem;
            border-radius: 0.25rem;
            margin-bottom: 0.5rem;
        }
        .mixing-card .recipe {
            font-size: 0.875rem;
            color: #666;
        }
        /* Image Analysis Section Styles */
        .image-analysis {
            margin-top: 2rem;
            padding: 1rem;
            border: 1px solid #e5e5e5;
            border-radius: 0.25rem;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            width: 100%;
            max-width: 64rem;
        }
        .image-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }
        .image-item {
            position: relative;
            cursor: pointer;
            border-radius: 0.25rem;
            overflow: hidden;
            aspect-ratio: 1 / 1;
            transition: transform 0.2s;
            border: 2px solid transparent;
        }
        .image-item:hover {
            transform: scale(1.05);
        }
        .image-item.selected {
            border-color: #007bff;
        }
        .image-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .color-analysis {
            margin-top: 1.5rem;
        }
        .analyzed-image {
            max-width: 100%;
            max-height: 300px;
            display: block;
            margin: 0 auto 1.5rem auto;
            border-radius: 0.25rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .color-palette {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
        }
        .palette-color {
            flex: 1;
            min-width: 150px;
            border: 1px solid #e5e5e5;
            border-radius: 0.25rem;
            overflow: hidden;
        }
        .color-swatch {
            height: 80px;
            width: 100%;
        }
        .color-details {
            padding: 0.75rem;
            font-size: 0.875rem;
        }
        .color-details p {
            margin: 0.25rem 0;
        }
        .loading-indicator {
            display: none;
            margin: 2rem auto;
            text-align: center;
        }
        .carousel-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 1rem 0;
        }
        .carousel-controls button {
            padding: 0.5rem 1rem;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 0.25rem;
            cursor: pointer;
            font-size: 0.875rem;
            transition: background-color 0.2s;
        }
        .carousel-controls button:hover {
            background-color: #0056b3;
        }
        .carousel-controls button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .pagination-info {
            font-size: 0.875rem;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>Interactive Color Wheel</h2>
        
        <div class="wheel-container">
            <svg
                id="colorWheel"
                width="340"
                height="340"
                viewBox="-170 -170 340 340"
                class="color-wheel"
            >
                <g id="wheelGroup">
                    <!-- Color segments will be inserted here -->
                    <circle cx="0" cy="0" r="80" fill="white" stroke="#333" stroke-width="1" />
                    <text x="0" y="0" text-anchor="middle" dominant-baseline="middle" font-size="12">
                        Pocket Color Wheel
                    </text>
                </g>
                <g id="pointer">
                    <line x1="0" y1="0" x2="160" y2="0" stroke="#000" stroke-width="2" />
                    <circle cx="160" cy="0" r="5" fill="#000" />
                </g>
            </svg>
        </div>
        
        <div class="color-display">
            <h3>Selected Color:</h3>
            <div id="selectedColorDisplay" class="color-tile"></div>
            
            <h3>50% Mixes:</h3>
            <div id="mixedColorsDisplay" class="color-grid"></div>
        </div>

        <div class="reverse-picker">
            <h3>Reverse Color Picker</h3>
            <div class="color-input-container">
                <input type="color" id="colorPicker" value="#ff0000">
                <button id="analyzeColor">Analyze Color</button>
            </div>
            <div id="mixingInstructions" class="mixing-instructions">
                <!-- Mixing instructions will be displayed here -->
            </div>
        </div>
        
        <div class="help-text">
            <p>Click and drag the color wheel to change the color. The pointer shows the selected color.</p>
            <p>All mixes show how the color looks when mixed 50% with different options.</p>
        </div>

        <!-- Image Analysis Section -->
        <div class="image-analysis">
            <h3>Image Color Analysis</h3>
            <p>Select an image to analyze its color palette. The analysis will show the 5 dominant colors and their RGB compositions.</p>
            
            <div class="carousel-controls">
                <button id="prevImages" disabled>← Previous</button>
                <span class="pagination-info" id="paginationInfo">Showing 1-12 of X images</span>
                <button id="nextImages">Next →</button>
            </div>
            
            <div class="image-grid" id="imageGrid">
                <!-- Images will be loaded here from images.json -->
                <div class="loading-indicator" id="imageLoadingIndicator">Loading images...</div>
            </div>

            <div class="color-analysis" id="colorAnalysis" style="display: none;">
                <h3>Color Analysis Results</h3>
                <img id="analyzedImage" class="analyzed-image" src="" alt="Analyzed image">
                
                <div class="color-palette" id="colorPalette">
                    <!-- Extracted colors will be displayed here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // Color definitions
        const colorDefinitions = [
            { name: 'Red', hsl: [0, 100, 50], position: 0 },
            { name: 'Red-Orange', hsl: [15, 100, 50], position: 15 },
            { name: 'Orange', hsl: [30, 100, 50], position: 30 },
            { name: 'Yellow-Orange', hsl: [45, 100, 50], position: 45 },
            { name: 'Yellow', hsl: [60, 100, 50], position: 60 },
            { name: 'Yellow-Green', hsl: [90, 100, 50], position: 90 },
            { name: 'Green', hsl: [120, 100, 50], position: 120 },
            { name: 'Blue-Green', hsl: [150, 100, 50], position: 150 },
            { name: 'Cyan', hsl: [180, 100, 50], position: 180 },
            { name: 'Blue', hsl: [210, 100, 50], position: 210 },
            { name: 'Blue-Violet', hsl: [240, 100, 50], position: 240 },
            { name: 'Violet', hsl: [270, 100, 50], position: 270 },
            { name: 'Red-Violet', hsl: [300, 100, 50], position: 300 },
            { name: 'Red', hsl: [360, 100, 50], position: 360 }
        ];

        const mixOptions = [
            { name: 'Complementary' },
            { name: 'Red', hsl: [0, 100, 50] },
            { name: 'Yellow', hsl: [60, 100, 50] },
            { name: 'Blue', hsl: [210, 100, 50] },
            { name: 'White', hsl: [0, 0, 100] },
            { name: 'Black', hsl: [0, 0, 0] }
        ];

        let rotation = 0;
        let isDragging = false;
        let startAngle = 0;
        let selectedColor = null;

        // DOM Elements
        const wheel = document.getElementById('colorWheel');
        const wheelGroup = document.getElementById('wheelGroup');
        const selectedColorDisplay = document.getElementById('selectedColorDisplay');
        const mixedColorsDisplay = document.getElementById('mixedColorsDisplay');

        // Initialize color wheel segments
        function renderColorWheel() {
            const segmentCount = 12;
            const segmentAngle = 360 / segmentCount;
            
            for (let i = 0; i < segmentCount; i++) {
                const startAngle = i * segmentAngle;
                const endAngle = (i + 1) * segmentAngle;
                const midAngle = (startAngle + endAngle) / 2;
                
                let segmentColor;
                for (let j = 1; j < colorDefinitions.length; j++) {
                    if (midAngle >= colorDefinitions[j-1].position && 
                        midAngle < colorDefinitions[j].position) {
                        const prevColor = colorDefinitions[j-1];
                        const nextColor = colorDefinitions[j];
                        const range = nextColor.position - prevColor.position;
                        const ratio = (midAngle - prevColor.position) / range;
                        
                        const h = prevColor.hsl[0] + ratio * (nextColor.hsl[0] - prevColor.hsl[0]);
                        segmentColor = `hsl(${h}, 100%, 50%)`;
                        break;
                    }
                }
                
                const startRad = startAngle * (Math.PI / 180);
                const endRad = endAngle * (Math.PI / 180);
                const innerRadius = 80;
                const outerRadius = 150;
                
                const startOuterX = Math.cos(startRad) * outerRadius;
                const startOuterY = Math.sin(startRad) * outerRadius;
                const endOuterX = Math.cos(endRad) * outerRadius;
                const endOuterY = Math.sin(endRad) * outerRadius;
                const startInnerX = Math.cos(startRad) * innerRadius;
                const startInnerY = Math.sin(startRad) * innerRadius;
                const endInnerX = Math.cos(endRad) * innerRadius;
                const endInnerY = Math.sin(endRad) * innerRadius;
                
                const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                path.setAttribute("d", `
                    M ${startOuterX} ${startOuterY}
                    A ${outerRadius} ${outerRadius} 0 0 1 ${endOuterX} ${endOuterY}
                    L ${endInnerX} ${endInnerY}
                    A ${innerRadius} ${innerRadius} 0 0 0 ${startInnerX} ${startInnerY}
                    Z
                `);
                path.setAttribute("fill", segmentColor);
                path.setAttribute("stroke", "#333");
                path.setAttribute("stroke-width", "1");
                
                wheelGroup.insertBefore(path, wheelGroup.firstChild);
            }
        }

        // Mouse event handlers
        wheel.addEventListener('mousedown', (e) => {
            isDragging = true;
            const rect = wheel.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const x = e.clientX - centerX;
            const y = e.clientY - centerY;
            startAngle = Math.atan2(y, x) * (180 / Math.PI) - rotation;
        });

        wheel.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const rect = wheel.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                const x = e.clientX - centerX;
                const y = e.clientY - centerY;
                const angle = Math.atan2(y, x) * (180 / Math.PI);
                let newRotation = angle - startAngle;
                
                if (newRotation < 0) newRotation += 360;
                if (newRotation >= 360) newRotation -= 360;
                
                rotation = newRotation;
                wheelGroup.style.transform = `rotate(${rotation}deg)`;
                updateSelectedColor(rotation);
            }
        });

        wheel.addEventListener('mouseup', () => {
            isDragging = false;
        });

        wheel.addEventListener('mouseleave', () => {
            isDragging = false;
        });

        // Color mixing functions
        function mixHue(h1, h2) {
            const diff = Math.abs(h1 - h2);
            if (diff > 180) {
                if (h1 < h2) {
                    h1 += 360;
                } else {
                    h2 += 360;
                }
            }
            const result = (h1 + h2) / 2;
            return result % 360;
        }

        function mixSat(s1, s2) {
            return (s1 + s2) / 2;
        }

        function mixLightness(l1, l2) {
            return (l1 + l2) / 2;
        }

        function calculateMixedHsl(baseColor, mixOption) {
            const [h, s, l] = baseColor.hsl;
            
            switch (mixOption.name) {
                case 'Complementary':
                    return [(h + 180) % 360, s, l];
                case 'Red':
                case 'Yellow':
                case 'Blue':
                case 'White':
                case 'Black':
                    return [
                        mixHue(h, mixOption.hsl[0]), 
                        mixSat(s, mixOption.hsl[1]), 
                        mixLightness(l, mixOption.hsl[2])
                    ];
                default:
                    return [h, s, l];
            }
        }

        // Update selected color and mixed colors
        function updateSelectedColor(angle) {
            let normalizedAngle = (360 - angle) % 360;
            
            let selectedColorObj = colorDefinitions[0];
            for (let i = 1; i < colorDefinitions.length; i++) {
                if (normalizedAngle >= colorDefinitions[i-1].position && 
                    normalizedAngle < colorDefinitions[i].position) {
                    const prevColor = colorDefinitions[i-1];
                    const nextColor = colorDefinitions[i];
                    const range = nextColor.position - prevColor.position;
                    const ratio = (normalizedAngle - prevColor.position) / range;
                    
                    const h = prevColor.hsl[0] + ratio * (nextColor.hsl[0] - prevColor.hsl[0]);
                    const s = prevColor.hsl[1];
                    const l = prevColor.hsl[2];
                    
                    selectedColorObj = {
                        name: `${prevColor.name} - ${nextColor.name}`,
                        hsl: [h, s, l],
                        position: normalizedAngle
                    };
                    break;
                }
            }
            
            selectedColor = selectedColorObj;
            updateDisplays(selectedColor);
        }

        function updateDisplays(selectedColor) {
            // Update selected color display
            selectedColorDisplay.innerHTML = `
                <div class="color-tile-title">${selectedColor.name}:</div>
                <div class="color-tile-box" style="background-color: hsl(${selectedColor.hsl[0]}, ${selectedColor.hsl[1]}%, ${selectedColor.hsl[2]}%)"></div>
                <div class="color-tile-hsl">HSL: ${Math.round(selectedColor.hsl[0])}°, ${Math.round(selectedColor.hsl[1])}%, ${Math.round(selectedColor.hsl[2])}%</div>
            `;

            // Update mixed colors display
            mixedColorsDisplay.innerHTML = mixOptions.map(option => {
                const mixedHsl = calculateMixedHsl(selectedColor, option);
                return `
                    <div class="color-mix">
                        <div class="color-tile-title">${option.name}</div>
                        <div class="color-tile-box" style="background-color: hsl(${mixedHsl[0]}, ${mixedHsl[1]}%, ${mixedHsl[2]}%)"></div>
                        <div class="color-tile-hsl">HSL: ${Math.round(mixedHsl[0])}°, ${Math.round(mixedHsl[1])}%, ${Math.round(mixedHsl[2])}%</div>
                    </div>
                `;
            }).join('');
        }

        // Initialize
        renderColorWheel();
        updateSelectedColor(rotation);

        // Add reverse color picker functionality
        const colorPicker = document.getElementById('colorPicker');
        const analyzeButton = document.getElementById('analyzeColor');
        const mixingInstructions = document.getElementById('mixingInstructions');

        function rgbToHsl(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }

            return [
                Math.round(h * 360),
                Math.round(s * 100),
                Math.round(l * 100)
            ];
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function findClosestColor(hsl) {
            let closest = colorDefinitions[0];
            let minDistance = Infinity;

            for (const color of colorDefinitions) {
                const distance = Math.abs(color.hsl[0] - hsl[0]);
                if (distance < minDistance) {
                    minDistance = distance;
                    closest = color;
                }
            }

            return closest;
        }

        function generateMixingInstructions(targetHsl) {
            const primaryColors = [
                { name: 'Red', hsl: [0, 100, 50] },
                { name: 'Yellow', hsl: [60, 100, 50] },
                { name: 'Blue', hsl: [210, 100, 50] }
            ];

            const secondaryColors = [
                { name: 'Orange', hsl: [30, 100, 50] },
                { name: 'Green', hsl: [120, 100, 50] },
                { name: 'Violet', hsl: [270, 100, 50] }
            ];

            const instructions = [];

            // Mix with primary colors
            primaryColors.forEach(primary => {
                const mixRatio = calculateMixRatio(targetHsl, primary.hsl);
                if (mixRatio) {
                    instructions.push({
                        title: `Mix with ${primary.name}`,
                        color: `hsl(${targetHsl[0]}, ${targetHsl[1]}%, ${targetHsl[2]}%)`,
                        recipe: `${Math.round(mixRatio * 100)}% ${primary.name} + ${Math.round((1 - mixRatio) * 100)}% White`
                    });
                }
            });

            // Mix with secondary colors
            secondaryColors.forEach(secondary => {
                const mixRatio = calculateMixRatio(targetHsl, secondary.hsl);
                if (mixRatio) {
                    instructions.push({
                        title: `Mix with ${secondary.name}`,
                        color: `hsl(${targetHsl[0]}, ${targetHsl[1]}%, ${targetHsl[2]}%)`,
                        recipe: `${Math.round(mixRatio * 100)}% ${secondary.name} + ${Math.round((1 - mixRatio) * 100)}% White`
                    });
                }
            });

            return instructions;
        }

        function calculateMixRatio(targetHsl, baseHsl) {
            // Simple approximation - in reality, color mixing is more complex
            const hueDiff = Math.abs(targetHsl[0] - baseHsl[0]);
            if (hueDiff > 180) {
                return null; // Colors are too far apart
            }
            return hueDiff / 180;
        }

        function displayMixingInstructions(instructions) {
            mixingInstructions.innerHTML = instructions.map(instruction => `
                <div class="mixing-card">
                    <h4>${instruction.title}</h4>
                    <div class="color-preview" style="background-color: ${instruction.color}"></div>
                    <div class="recipe">${instruction.recipe}</div>
                </div>
            `).join('');
        }

        analyzeButton.addEventListener('click', () => {
            const hexColor = colorPicker.value;
            const rgb = hexToRgb(hexColor);
            if (rgb) {
                const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
                const instructions = generateMixingInstructions(hsl);
                displayMixingInstructions(instructions);
            }
        });

        // Image Analysis Functionality
        const imageGrid = document.getElementById('imageGrid');
        const colorAnalysis = document.getElementById('colorAnalysis');
        const analyzedImage = document.getElementById('analyzedImage');
        const colorPalette = document.getElementById('colorPalette');
        const imageLoadingIndicator = document.getElementById('imageLoadingIndicator');
        const prevImagesBtn = document.getElementById('prevImages');
        const nextImagesBtn = document.getElementById('nextImages');
        const paginationInfo = document.getElementById('paginationInfo');
        
        // Pagination variables
        let currentPage = 0;
        let imagesPerPage = 12;
        let totalImages = 0;
        let allImages = [];

        // Fetch images from images.json
        async function loadImages() {
            try {
                imageLoadingIndicator.style.display = 'block';
                const response = await fetch('images.json');
                const data = await response.json();
                
                // Store all images and count
                allImages = data.images;
                totalImages = allImages.length;
                
                // Display initial set of images
                displayImages();
                
                // Setup navigation buttons
                updatePaginationControls();
                
                // Add event listeners for navigation
                prevImagesBtn.addEventListener('click', showPreviousImages);
                nextImagesBtn.addEventListener('click', showNextImages);
            } catch (error) {
                console.error('Error loading images:', error);
                imageGrid.innerHTML = '<p>Error loading images. Please try again later.</p>';
            } finally {
                imageLoadingIndicator.style.display = 'none';
            }
        }
        
        // Display current page of images
        function displayImages() {
            // Calculate start and end indices
            const startIndex = currentPage * imagesPerPage;
            const endIndex = Math.min(startIndex + imagesPerPage, totalImages);
            
            // Get current set of images
            const currentImages = allImages.slice(startIndex, endIndex);
            
            // Generate HTML
            const imageHtml = currentImages.map((image, index) => `
                <div class="image-item" data-url="${image.url}" data-index="${startIndex + index}">
                    <img src="${image.url}" alt="Image ${startIndex + index + 1}" loading="lazy">
                </div>
            `).join('');
            
            // Update grid
            imageGrid.innerHTML = imageHtml;
            
            // Update pagination information
            paginationInfo.textContent = `Showing ${startIndex + 1}-${endIndex} of ${totalImages} images`;
            
            // Add click event listeners to images
            document.querySelectorAll('.image-item').forEach(item => {
                item.addEventListener('click', handleImageSelect);
            });
        }
        
        // Show previous page of images
        function showPreviousImages() {
            if (currentPage > 0) {
                currentPage--;
                displayImages();
                updatePaginationControls();
            }
        }
        
        // Show next page of images
        function showNextImages() {
            const maxPages = Math.ceil(totalImages / imagesPerPage);
            if (currentPage < maxPages - 1) {
                currentPage++;
                displayImages();
                updatePaginationControls();
            }
        }
        
        // Update the state of pagination controls
        function updatePaginationControls() {
            prevImagesBtn.disabled = currentPage === 0;
            nextImagesBtn.disabled = currentPage >= Math.ceil(totalImages / imagesPerPage) - 1;
        }

        // Handle image selection
        function handleImageSelect(e) {
            // Remove selected class from all images
            document.querySelectorAll('.image-item').forEach(item => {
                item.classList.remove('selected');
            });
            
            // Add selected class to clicked image
            const selectedItem = e.currentTarget;
            selectedItem.classList.add('selected');
            
            // Get the image URL
            const imageUrl = selectedItem.dataset.url;
            
            // Set the analyzed image
            analyzedImage.src = imageUrl;
            
            // Analyze the image
            analyzeImageColors(imageUrl);
            
            // Show the analysis section
            colorAnalysis.style.display = 'block';
            
            // Scroll to analysis
            colorAnalysis.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        // Analyze image colors using Canvas
        function analyzeImageColors(imageUrl) {
            const img = new Image();
            img.crossOrigin = 'Anonymous';
            
            img.onload = () => {
                // Create canvas element
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Set canvas dimensions
                canvas.width = img.width;
                canvas.height = img.height;
                
                // Draw image on canvas
                ctx.drawImage(img, 0, 0);
                
                // Get image data
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const pixels = imageData.data;
                
                // Analyze colors
                const colorMap = {};
                
                // Sample pixels (sample every 5th pixel for performance)
                for (let i = 0; i < pixels.length; i += 20) {
                    const r = pixels[i];
                    const g = pixels[i + 1];
                    const b = pixels[i + 2];
                    const a = pixels[i + 3];
                    
                    // Skip transparent pixels
                    if (a < 125) continue;
                    
                    // Quantize colors slightly to reduce the number of unique colors
                    const quantizedR = Math.round(r / 10) * 10;
                    const quantizedG = Math.round(g / 10) * 10;
                    const quantizedB = Math.round(b / 10) * 10;
                    
                    const colorKey = `${quantizedR},${quantizedG},${quantizedB}`;
                    
                    if (colorMap[colorKey]) {
                        colorMap[colorKey].count++;
                    } else {
                        colorMap[colorKey] = {
                            r: quantizedR,
                            g: quantizedG,
                            b: quantizedB,
                            count: 1
                        };
                    }
                }
                
                // Convert to array and sort by count
                const colors = Object.values(colorMap).sort((a, b) => b.count - a.count);
                
                // Take top 5 colors with sufficient difference
                const dominantColors = [];
                let index = 0;
                
                while (dominantColors.length < 5 && index < colors.length) {
                    const color = colors[index];
                    
                    // Check if this color is sufficiently different from already selected colors
                    const isDifferent = dominantColors.every(selectedColor => {
                        const colorDistance = Math.sqrt(
                            Math.pow(selectedColor.r - color.r, 2) +
                            Math.pow(selectedColor.g - color.g, 2) +
                            Math.pow(selectedColor.b - color.b, 2)
                        );
                        
                        return colorDistance > 30; // Threshold for "different enough"
                    });
                    
                    if (isDifferent || dominantColors.length === 0) {
                        dominantColors.push(color);
                    }
                    
                    index++;
                }
                
                // Display the results
                displayColorPalette(dominantColors);
            };
            
            img.onerror = () => {
                colorPalette.innerHTML = '<p>Error analyzing image. The image might be protected or unavailable.</p>';
                colorAnalysis.style.display = 'block';
            };
            
            img.src = imageUrl;
        }

        // Display color palette
        function displayColorPalette(colors) {
            const colorHtml = colors.map(color => {
                const { r, g, b } = color;
                
                // Calculate value percentage (inverted - darker colors have higher values)
                const value = 100 - Math.max(r, g, b) / 255 * 100;
                
                // Calculate RGB percentages (ensure they add up to 100%)
                const total = r + g + b;
                let rPercent, gPercent, bPercent;
                
                if (total === 0) {
                    // Handle black (avoid division by zero)
                    rPercent = gPercent = bPercent = 33.33; // Equal distribution for black
                } else {
                    rPercent = (r / total) * 100;
                    gPercent = (g / total) * 100;
                    bPercent = (b / total) * 100;
                }
                
                return `
                    <div class="palette-color">
                        <div class="color-swatch" style="background-color: rgb(${r}, ${g}, ${b})"></div>
                        <div class="color-details">
                            <p><strong>RGB:</strong> ${r}, ${g}, ${b}</p>
                            <p><strong>RGB %:</strong> R: ${rPercent.toFixed(0)}%, G: ${gPercent.toFixed(0)}%, B: ${bPercent.toFixed(0)}%</p>
                            <p><strong>Value:</strong> ${value.toFixed(0)}%</p>
                        </div>
                    </div>
                `;
            }).join('');
            
            colorPalette.innerHTML = colorHtml;
        }

        // Load images when the page is ready
        loadImages();
    </script>
</body>
</html>
